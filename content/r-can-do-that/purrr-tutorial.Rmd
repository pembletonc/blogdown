---
title: "Using purrr and working with nested dataframes"
author: "Corey Pembleton"
date: '2018-11-11'
output: html_document
draft: true
slug: purrr-and-nesting-dataframes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
```

## purrr tutorial: valuable lessons in map_*ing

I'm still learning the functionality behind purrr, the tidyverse package which helps with the commonly found challenges in data management relating to splitting data, applying analysis, and recombining the data. In this post, I just walk through my progress in the purrr tutorials, and a few other use cases. I will be doing this with a Canadian census dataset I created in a previous post  rather than the "Game of Thrones" dataset [Jenny Bryan](https://twitter.com/JennyBryan) uses. 

```{r, echo=FALSE, cache=TRUE, warning=FALSE, message=FALSE}
Census_2011 <- read_csv("./Census_2011.csv")
```

### First thing's first - understanding lists, lists of lists, and lists of dataframes

purrr, and its ```map_*()``` functions are fundamental to the tidyverse. I had been using them for some time, but really didn't understand the process which was occuring in the background. Starting with Hadley's R For Data Science section on [vectors](https://r4ds.had.co.nz/vectors.html#introduction-13), and [this note](https://blog.rstudio.com/2016/02/02/tidyr-0-4-0/) detailing the ```nest()``` ```tidyr``` function, I could gain some understanding of three concepts, that of lists, lists of lists, and lists of dataframes.

From r4ds, I learned that lists, also known as recursive vectors, are a type of vector (e.g. logical, integer, character) which unlike atomic vectors can contain a mix of atomic vectors. The structure of which is handily viewed using ```str()```

```{r}
y <- list("Canada", 32500, TRUE, 1L)
str(y)
```

And can contain other lists:

```{r}
z <- list(list("Canada", 32500), list(TRUE, 1L) )
str(z)
```

The hierarchical structure of the list of lists is important when considering the composition of a list containing multiple dataframes in a nested manner, and subsequently how the ```purrr::map()``` family of functions work. Interestingly, dataframes and tibbles are also lists, or augmented lists, with tibbles having the classes tbl_df, tbl, and data.frame. 

```{r}
#dataframe of a .csv derived dataset:

census_small <- slice(Census_2011, 3)
typeof(census_small)
attributes(census_small)

#tibble of a .csv-derived dataset

census_small_tb <- as.tibble(census_small)

typeof(census_small_tb)

attributes(census_small_tb)

```

With that understanding, I now see how a nested tibble or dataframe operates. Hadley Wickham describes a nested dataframe as 

> "In a grouped data frame, you have **one row per observation**, and additional metadata define the groups. In a nested data frame, you have **one row per group**, and the individual observations are stored in a column that is a list of data frames."

Without nesting, the data has over 64 variables with 5,452 observations, a fairly large dataset. Fortunately, I don't need to explore each province in the country, but rather a single province.

Nested we can view a grouped version of the data in a neater, rolled-up format, select out the data needed, and look at that subset in detail. 
```{r}
nested_census <- Census_2011 %>% 
  group_by(PRNAME) %>%
  nest()

nested_census
```

Aside from being neat, we see something interesting - a new column titled "data", which unsurprisingly is a list class. Looking at Newfoundland and Labrador's dataframe can be done through the same operators as with lists: with [, [[, or $, which shows the ungrouped data, in this case of the province: 

```{r}
nested_census$data[[5]]
```

Nesting and pulling out one of the "nested" dataframes in its ungrouped format is helpful for how data is structured, now I'd like to look at how this process can be used in analysis. 

## Back to map()

Now that I have my head wrapped around these structures, I can get back to the point: ```purrr::map()```. On CRAN, the family of ```map_*``` is titled as "apply a function to each element of a vector" - pretty much says exactly what it does.

The rdocumentation gives some simple examples which I'd like to breakdown further, which I follow here and refer to some other helpful stackoverflow and rdocumentation to expand on what is learned.

## 1. map() use case: passing functions through a list of vectors

In rdocumentation the first use of ```map()```, is presented as:

```{r, eval=FALSE}
1:10 %>%
  map(rnorm, n = 10) %>%
  map_dbl(mean)
```

The first line and ```map()``` give us a randomly generated normal distribution of each vector in the 1:10 sequence, with the result looking like:

```{r, echo=FALSE}
1:10 %>%
  map(rnorm, n = 10)
```

Based on the structure, we see that ```map()```, as described, passed a function (rnorm()) to each vector in 1:10. 

In the third line, we see that another function, ```mean()``` is being passed through each of the 10 rnorm generated values in the list:

```{r, echo=FALSE}
1:10 %>%
  map(rnorm, n = 10) %>%
  map_dbl(mean)
```

Another use-case which I see often, is to pass a formula through various pieces of a dataframe:

```{r, eval=FALSE}
mtcars %>%
  split(.$cyl) %>%
  map(~ lm(mpg ~ wt, data = .x)) %>%
  map(summary) %>%
  map_dbl("r.squared")
```

The second line, ```split(.$cyl)```, uses the base r function ```split()``` to split the dataframe based upon the 3 cyl groups, 4, 6, and 8.  


###side note: formulae usage in ```map()```  
> In the third line, we see ```map()``` being used to pass formula across each of these three groups for a regression of the mpg and wt variables. I know that it is a formula because it leads with a tilde (~). For formulas in ```map()```, it can take three arguments: 1) single use arguments: ```.```; 2) two-argument function: ```.x``` and ```.y``` and three, 3) more arguments: ```..1```, ```..2```, etc.

>Hence, ```map(~ lm(mpg ~ wt, data = .x))``` will pass the formula, with ```.x``` meaning that ```map``` will pass the formula across all unused data variables present in the data frame. It will have the same result using ``` map(~ lm(mpg ~ wt, data = .))```. 

In the subsequent lines, ```summary()``` provides the summary of the above linear regression model, and the ```map_dbl()``` does what ```map()``` does best: it passes through a list(summary, list of lm summary data for each of the three groups) and extracts based on the name. We could replace this with other summary variables in the list, such as adj.r.squared, sigma, fstatistic, and more.

### 






