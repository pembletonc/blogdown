---
title: "Using purrr and working with nested dataframes"
author: "Corey Pembleton"
date: '2018-11-11'
output: html_document
draft: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(purrr)
library(repurrrsive)
```

## purrr tutorial: valuable lessons in map_*ing

I'm still learning the functionality behind purrr, the tidyverse package which helps with the commonly found challenges in data management relating to splitting data, applying analysis, and recombining the data. In this post, I just walk through my progress in the purrr tutorials, and a few other use cases. I will be doing this with Canadian census income data rather than the "Game of Thrones" dataset [Jenny Bryan](https://twitter.com/JennyBryan) uses. 

```{r, echo=FALSE, cache=TRUE}
income <- read.csv("./content/space-stats/CAN_11_CT_AGE.csv")
```

### First things first - understanding lists, lists of lists, and lists of dataframes

purrr, and its ```map_*()``` functions are fundamental to the tidyverse. I had been using them for some time, but really didn't understand the process which was occuring in the background. Starting with Hadley's R For Data Science section on [vectors](https://r4ds.had.co.nz/vectors.html#introduction-13), and [this note](https://blog.rstudio.com/2016/02/02/tidyr-0-4-0/) detailing the ```nest()``` ```tidyr``` function, I could gain some understanding of two concepts, that of lists, of lists of lists, and of lists of dataframes.

From r4ds, I learned that lists, also known as recursive vectors, are a type of vector (e.g. logical, integer, character) which unlike atomic vectors can contain a mix of atomic vectors. The structure of which is handily viewed using ```str()```

```{r}
y <- list("Canada", 32500, TRUE, 1L)
str(y)
```

And can contain other lists:

```{r}
z <- list(list("Canada", 32500), list(TRUE, 1L) )
str(z)
```

The hierarchical structure of the list of lists is important when considering the composition of a list containing multiple dataframes in a nested manner, and subsequently how the ```purrr::map()``` family of functions work. Interestingly, dataframes and tibbles are also lists, or augmented lists, with tibbles having the classes tbl_df, tbl, and data.frame. 

```{r}
#dataframe of a .csv derived dataset:

income_small <- slice(income, 3)
typeof(income_small)
attributes(income_small)

#tibble of a .csv-derived dataset

income_small_tb <- as.tibble(income_small)

typeof(income_small_tb)
attributes(income_small_tb)

```

With that understanding, I now see how a nested tibble or dataframe operates.Hadley Wickham describes a nested dataframe as 

> "In a grouped data frame, you have **one row per observation**, and additional metadata define the groups. In a nested data frame, you have **one row per group**, and the individual observations are stored in a column that is a list of data frames."

Looking back at the 2011 Canada census data as it is structured originally :

```{r}
glimpse(income)
```

And how it would look if it was nested, grouped by province:

```{r}
nested_income <- income %>% 
  group_by(PRNAME) %>%
  nest()

nested_income
```

Aside from being neat, we see something interesting - a new column titled "data", which unsurprisingly is a list class. Looking at Newfoundland and Labrador's dataframe can be done through the same operators as with lists: with [, [[, or $, which shows the ungrouped data, in this case of the province: 


```{r}
nested_income$data[[5]]

```


## Back to map()

Now that I have my head wrapped around these structures, I can get back to the point: ```purrr:map()```. The first time I encountered this function was when searching for a way to pull a random stratified sample from a grouped summary, and was led to the ```purrr``` tutorial pages. 









