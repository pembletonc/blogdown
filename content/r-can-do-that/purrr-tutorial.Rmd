---
title: "Using purrr and working with nested dataframes"
author: "Corey Pembleton"
date: '2018-11-11'
output: html_document
draft: true
slug: purrr-and-nesting-dataframes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
```

## purrr tutorial: valuable lessons in map_*ing

I'm still learning the functionality behind purrr, the tidyverse package which helps with the commonly found challenges in data management relating to splitting, applying analysis, and recombining the data. In this post, I walk through my progress in various purrr tutorials, and a few use cases of the ```purrr::map()``` functions. I will be doing this with a Canadian census dataset I created in a [previous post](https://coreypembleton.netlify.com/space-stats/canadian-census-data-cleaning-pt1/)

```{r, echo=FALSE, cache=TRUE, warning=FALSE, message=FALSE}
Census_2011 <- read_csv("./Census_2011.csv")

```

### First thing's first - understanding lists, lists of lists, and lists of dataframes

purrr, and its ```map_*()``` functions are fundamental to executing functions in the tidyverse. I had been using ```map()``` and different purrr functions for some time but really didn't understand the underlying processes which made it all work. Starting with Hadley's R For Data Science (r4ds) section on [vectors](https://r4ds.had.co.nz/vectors.html#introduction-13), and [this note](https://blog.rstudio.com/2016/02/02/tidyr-0-4-0/) detailing the ```nest()``` ```tidyr``` function, I could gain some understanding of three concepts, that of lists, lists of lists, and lists of dataframes.

From r4ds, I learned that lists, also known as recursive vectors, are a type of vector  which unlike atomic vectors (e.g. logical, integer, character) can contain a mix of different types of atomic vectors. The structure of lists can be  viewed using ```str()```:

```{r}
y <- list("Canada", 32500, TRUE, 1L)
str(y)
```

Lists can contain other lists:

```{r}
z <- list(list("Canada", 32500), list(TRUE, 1L) )
str(z)
```

The hierarchical structure of the nested list is important when considering the composition of a list containing multiple dataframes in a nested manner, and subsequently how the ```purrr::map()``` family of functions work. Interestingly, dataframes and tibbles are also lists, or augmented lists, with tibbles having the classes tbl_df, tbl, and data.frame, as can be seen with the ```attributes()``` function (not shown). 

```{r}
#dataframe of a .csv derived dataset:

census_small_df <- Census_2011[,3:10]
typeof(census_small_df)

#tibble of a .csv-derived dataset

census_small <- as.tibble(census_small_df)

typeof(census_small)

```

### Nested Dataframes  

With that understanding, I can now understand how a nested tibble or dataframe operates. Hadley Wickham describes a nested dataframe as: 

> "In a grouped data frame, you have **one row per observation**, and additional metadata define the groups. In a nested data frame, you have **one row per group**, and the individual observations are stored in a column that is a list of data frames."


```{r}
nested_census <- census_small %>% 
  group_by(PRNAME) %>%
  nest()

nested_census
```

Aside from being neat, we see something interesting - a new column titled "data", which unsurprisingly is a list class. Looking at Newfoundland and Labrador's dataframe can be done through the same operators as with lists: with [, [[, or $, which shows the ungrouped data, in this case of the province: 

```{r}
nested_census$data[[5]]
```

Nesting and pulling out one of the "nested" dataframes in its ungrouped format is helpful for how data is structured, now I'd like to look at how this process can be used in analysis. 

## Back to map()

Now that I have my head wrapped around these structures, I can get back to the point: ```purrr::map()```. On CRAN, the function family of ```map_()``` is titled as "apply a function to each element of a vector" - pretty much says exactly what it does.

The rdocumentation gives some simple examples which I'd like to breakdown further, which I follow here and refer to some other helpful stackoverflow and rdocumentation to expand on what is learned.

### map() use case 1: passing functions through a list of vectors

In rdocumentation the first use of ```map()```, is presented as:

```{r, eval=FALSE}
1:10 %>%
  map(rnorm, n = 10) %>%
  map_dbl(mean)
```

The first line and ```map()``` give us a randomly generated normal distribution of each vector in the 1:10 sequence, with the result looking like:

```{r, echo=FALSE}
1:10 %>%
  map(rnorm, n = 10)
```

Based on the structure, we see that ```map()```, as described, passed a function (rnorm()) to each vector in 1:10. 

In the third line, we see that another function, ```mean()``` is being passed through each of the 10 rnorm generated values in the list:

```{r, echo=FALSE}
1:10 %>%
  map(rnorm, n = 10) %>%
  map_dbl(mean)
```

### map() use case #2: passing a formula through parts of a dataframe
Another use-case which I see often, is to pass a formula through various pieces of a dataframe. In the rdocumentation script below, we see three uses of ```map()```, a formula object being passed through a split dataframe, a function ```summary()``` being called, and a named vector from a nested list "r.squared" being called:

```{r, eval=FALSE}
mtcars %>%
  split(.$cyl) %>%
  map(~ lm(mpg ~ wt, data = .x)) %>%
  map(summary) %>%
  map_dbl("r.squared")
```

The second line, ```split(.$cyl)```, uses the base r function ```split()``` to split the dataframe based upon the 3 cyl groups, 4, 6, and 8.  

In the third line,  ```map()``` is being used to pass formula across each of these three groups created, which is a regression between the mpg and wt variables. Formulas in ```map()```, can take three arguments:  

1.  single use arguments: ```.```; 
2.  two-argument function: ```.x``` and ```.y``` and; 
3.  more than two arguments: ```..1```, ```..2```, etc.

Hence, ```map(~ lm(mpg ~ wt, data = .x))``` will pass the formula, with ```.x``` meaning that ```map``` will pass the formula across all unused data variables present in the data frame. It will have the same result using ``` map(~ lm(mpg ~ wt, data = .))```. 

> Note on the tilde (~): tildes are used in formula objects in R, such as within the lm() formula used above. with map() there is an additional ~ before the lm() function when used in map() to [identify the expression as being a formula object](https://stackoverflow.com/questions/44834446/what-is-meaning-of-first-tilde-in-purrrmap). 


In the subsequent lines, map passed the```summary()``` function over each of the resultant groups' linear model, and the ```map_dbl()``` does what ```map()``` does best: it passes through a nested list (summay output) and extracts based on the character vector name "r.squared". We could replace this with other summary variables in the list, such as adj.r.squared, sigma, fstatistic, and more.

### 






